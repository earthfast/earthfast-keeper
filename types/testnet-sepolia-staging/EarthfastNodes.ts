/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type EarthfastSlotStruct = {
  last: PromiseOrValue<boolean>;
  next: PromiseOrValue<boolean>;
};

export type EarthfastSlotStructOutput = [boolean, boolean] & {
  last: boolean;
  next: boolean;
};

export type EarthfastCreateNodeDataStruct = {
  host: PromiseOrValue<string>;
  region: PromiseOrValue<string>;
  topology: PromiseOrValue<boolean>;
  disabled: PromiseOrValue<boolean>;
  price: PromiseOrValue<BigNumberish>;
};

export type EarthfastCreateNodeDataStructOutput = [
  string,
  string,
  boolean,
  boolean,
  BigNumber
] & {
  host: string;
  region: string;
  topology: boolean;
  disabled: boolean;
  price: BigNumber;
};

export type EarthfastNodeStruct = {
  id: PromiseOrValue<BytesLike>;
  operatorId: PromiseOrValue<BytesLike>;
  host: PromiseOrValue<string>;
  region: PromiseOrValue<string>;
  topology: PromiseOrValue<boolean>;
  disabled: PromiseOrValue<boolean>;
  prices: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  projectIds: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>];
};

export type EarthfastNodeStructOutput = [
  string,
  string,
  string,
  string,
  boolean,
  boolean,
  [BigNumber, BigNumber],
  [string, string]
] & {
  id: string;
  operatorId: string;
  host: string;
  region: string;
  topology: boolean;
  disabled: boolean;
  prices: [BigNumber, BigNumber];
  projectIds: [string, string];
};

export interface EarthfastNodesInterface extends utils.Interface {
  functions: {
    "DEFAULT_ADMIN_ROLE()": FunctionFragment;
    "IMPORTER_ROLE()": FunctionFragment;
    "TOPOLOGY_CREATOR_ROLE()": FunctionFragment;
    "advanceNodeEpochImpl(bytes32)": FunctionFragment;
    "createNodes(bytes32,bool,(string,string,bool,bool,uint256)[])": FunctionFragment;
    "deleteNodes(bytes32,bool,bytes32[])": FunctionFragment;
    "getNode(bytes32)": FunctionFragment;
    "getNodeCount(bytes32,bool)": FunctionFragment;
    "getNodes(bytes32,bool,uint256,uint256)": FunctionFragment;
    "getRegistry()": FunctionFragment;
    "getRoleAdmin(bytes32)": FunctionFragment;
    "grantRole(bytes32,address)": FunctionFragment;
    "hasRole(bytes32,address)": FunctionFragment;
    "initialize(address[],address,bool)": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "renounceRole(bytes32,address)": FunctionFragment;
    "revokeRole(bytes32,address)": FunctionFragment;
    "setNodeDisabled(bytes32,bytes32[],bool[])": FunctionFragment;
    "setNodeHosts(bytes32,bytes32[],string[],string[])": FunctionFragment;
    "setNodePriceImpl(bytes32,uint256,uint256)": FunctionFragment;
    "setNodePrices(bytes32,bytes32[],uint256[],(bool,bool))": FunctionFragment;
    "setNodeProjectImpl(bytes32,uint256,bytes32)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "unpause()": FunctionFragment;
    "unsafeImportData((bytes32,bytes32,string,string,bool,bool,uint256[2],bytes32[2])[],address[],bool)": FunctionFragment;
    "unsafeSetPrices(uint256,uint256,uint256,uint256)": FunctionFragment;
    "unsafeSetRegistry(address)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DEFAULT_ADMIN_ROLE"
      | "IMPORTER_ROLE"
      | "TOPOLOGY_CREATOR_ROLE"
      | "advanceNodeEpochImpl"
      | "createNodes"
      | "deleteNodes"
      | "getNode"
      | "getNodeCount"
      | "getNodes"
      | "getRegistry"
      | "getRoleAdmin"
      | "grantRole"
      | "hasRole"
      | "initialize"
      | "pause"
      | "paused"
      | "proxiableUUID"
      | "renounceRole"
      | "revokeRole"
      | "setNodeDisabled"
      | "setNodeHosts"
      | "setNodePriceImpl"
      | "setNodePrices"
      | "setNodeProjectImpl"
      | "supportsInterface"
      | "unpause"
      | "unsafeImportData"
      | "unsafeSetPrices"
      | "unsafeSetRegistry"
      | "upgradeTo"
      | "upgradeToAndCall"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "IMPORTER_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOPOLOGY_CREATOR_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "advanceNodeEpochImpl",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "createNodes",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      EarthfastCreateNodeDataStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteNodes",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getNode",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNodeCount",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNodes",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRoleAdmin",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "grantRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setNodeDisabled",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<boolean>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setNodeHosts",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<string>[],
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setNodePriceImpl",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setNodePrices",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BigNumberish>[],
      EarthfastSlotStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setNodeProjectImpl",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "unsafeImportData",
    values: [
      EarthfastNodeStruct[],
      PromiseOrValue<string>[],
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unsafeSetPrices",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unsafeSetRegistry",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "IMPORTER_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOPOLOGY_CREATOR_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "advanceNodeEpochImpl",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNodes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteNodes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNode", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNodeCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNodes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoleAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setNodeDisabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNodeHosts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNodePriceImpl",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNodePrices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNodeProjectImpl",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unsafeImportData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unsafeSetPrices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unsafeSetRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "NodeCreated(bytes32,bytes32,string,string,bool,bool,uint256)": EventFragment;
    "NodeDeleted(bytes32,bytes32,string,string,bool,bool,uint256)": EventFragment;
    "NodeDisabledChanged(bytes32,bool,bool)": EventFragment;
    "NodeHostChanged(bytes32,string,string,string,string)": EventFragment;
    "NodePriceChanged(bytes32,uint256,uint256,uint256,tuple)": EventFragment;
    "Paused(address)": EventFragment;
    "RoleAdminChanged(bytes32,bytes32,bytes32)": EventFragment;
    "RoleGranted(bytes32,address,address)": EventFragment;
    "RoleRevoked(bytes32,address,address)": EventFragment;
    "Unpaused(address)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeDeleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeDisabledChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeHostChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodePriceChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleAdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface NodeCreatedEventObject {
  nodeId: string;
  operatorId: string;
  host: string;
  region: string;
  topology: boolean;
  disabled: boolean;
  price: BigNumber;
}
export type NodeCreatedEvent = TypedEvent<
  [string, string, string, string, boolean, boolean, BigNumber],
  NodeCreatedEventObject
>;

export type NodeCreatedEventFilter = TypedEventFilter<NodeCreatedEvent>;

export interface NodeDeletedEventObject {
  nodeId: string;
  operatorId: string;
  host: string;
  region: string;
  topology: boolean;
  disabled: boolean;
  price: BigNumber;
}
export type NodeDeletedEvent = TypedEvent<
  [string, string, string, string, boolean, boolean, BigNumber],
  NodeDeletedEventObject
>;

export type NodeDeletedEventFilter = TypedEventFilter<NodeDeletedEvent>;

export interface NodeDisabledChangedEventObject {
  nodeId: string;
  oldDisabled: boolean;
  newDisabled: boolean;
}
export type NodeDisabledChangedEvent = TypedEvent<
  [string, boolean, boolean],
  NodeDisabledChangedEventObject
>;

export type NodeDisabledChangedEventFilter =
  TypedEventFilter<NodeDisabledChangedEvent>;

export interface NodeHostChangedEventObject {
  nodeId: string;
  oldHost: string;
  oldRegion: string;
  newHost: string;
  newRegion: string;
}
export type NodeHostChangedEvent = TypedEvent<
  [string, string, string, string, string],
  NodeHostChangedEventObject
>;

export type NodeHostChangedEventFilter = TypedEventFilter<NodeHostChangedEvent>;

export interface NodePriceChangedEventObject {
  nodeId: string;
  oldLastPrice: BigNumber;
  oldNextPrice: BigNumber;
  newPrice: BigNumber;
  slot: EarthfastSlotStructOutput;
}
export type NodePriceChangedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, EarthfastSlotStructOutput],
  NodePriceChangedEventObject
>;

export type NodePriceChangedEventFilter =
  TypedEventFilter<NodePriceChangedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RoleAdminChangedEventObject {
  role: string;
  previousAdminRole: string;
  newAdminRole: string;
}
export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  RoleAdminChangedEventObject
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export interface RoleGrantedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  RoleGrantedEventObject
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export interface RoleRevokedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  RoleRevokedEventObject
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface EarthfastNodes extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: EarthfastNodesInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    IMPORTER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    TOPOLOGY_CREATOR_ROLE(overrides?: CallOverrides): Promise<[string]>;

    advanceNodeEpochImpl(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodes: EarthfastCreateNodeDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Unregisters nodes from the network and unlocks operator stake. Reverts if nodes are reserved.
     */
    deleteNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodeIds: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Reverts if the id is unknown
     */
    getNode(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[EarthfastNodeStructOutput]>;

    getNodeCount(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Truncates the results if skip or size are out of bounds
     */
    getNodes(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [EarthfastNodeStructOutput[]] & { values: EarthfastNodeStructOutput[] }
    >;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.
     */
    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Called once to set up the contract. Not called during proxy upgrades.
     * @param grantImporterRole allows the contract deployer to import initial data into the contract using unsafeImport* functions, which is used for proxy-less upgrades. CAUTION: Once import is finished, the importer role should be explicitly revoked.
     */
    initialize(
      admins: PromiseOrValue<string>[],
      registry: PromiseOrValue<string>,
      grantImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the contract is paused, and false otherwise.
     */
    paused(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.
     */
    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.
     */
    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Disabled nodes won't take new reservations and won't renew when epoch ends. Disabled nodes will still keep their current reservations until the end of the current epoch. Reenabled nodes will not retain their old reservations, and will need to be reserved again. Reverts if enabling or disabling nodes too close before next epoch start, as set by EarthfastRegistry gracePeriod.
     */
    setNodeDisabled(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      disabled: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Does not check host or region for validity or uniqueness
     * Changes content node or topology node hosts and regions. Reverts if nodes are reserved (unless admin).
     */
    setNodeHosts(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      hosts: PromiseOrValue<string>[],
      regions: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNodePriceImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNodePrices(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      prices: PromiseOrValue<BigNumberish>[],
      slot: EarthfastSlotStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNodeProjectImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unsafeImportData(
      nodes: EarthfastNodeStruct[],
      topologyCreators: PromiseOrValue<string>[],
      revokeImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Adjusts multiple content nodes prices relative to their current values.CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetPrices(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      mul: PromiseOrValue<BigNumberish>,
      div: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  IMPORTER_ROLE(overrides?: CallOverrides): Promise<string>;

  TOPOLOGY_CREATOR_ROLE(overrides?: CallOverrides): Promise<string>;

  advanceNodeEpochImpl(
    nodeId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createNodes(
    operatorId: PromiseOrValue<BytesLike>,
    topology: PromiseOrValue<boolean>,
    nodes: EarthfastCreateNodeDataStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Unregisters nodes from the network and unlocks operator stake. Reverts if nodes are reserved.
   */
  deleteNodes(
    operatorId: PromiseOrValue<BytesLike>,
    topology: PromiseOrValue<boolean>,
    nodeIds: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Reverts if the id is unknown
   */
  getNode(
    nodeId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<EarthfastNodeStructOutput>;

  getNodeCount(
    operatorIdOrZero: PromiseOrValue<BytesLike>,
    topology: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Truncates the results if skip or size are out of bounds
   */
  getNodes(
    operatorIdOrZero: PromiseOrValue<BytesLike>,
    topology: PromiseOrValue<boolean>,
    skip: PromiseOrValue<BigNumberish>,
    size: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<EarthfastNodeStructOutput[]>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(
    role: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.
   */
  grantRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Called once to set up the contract. Not called during proxy upgrades.
   * @param grantImporterRole allows the contract deployer to import initial data into the contract using unsafeImport* functions, which is used for proxy-less upgrades. CAUTION: Once import is finished, the importer role should be explicitly revoked.
   */
  initialize(
    admins: PromiseOrValue<string>[],
    registry: PromiseOrValue<string>,
    grantImporterRole: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the contract is paused, and false otherwise.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
   */
  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.
   */
  renounceRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.
   */
  revokeRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Disabled nodes won't take new reservations and won't renew when epoch ends. Disabled nodes will still keep their current reservations until the end of the current epoch. Reenabled nodes will not retain their old reservations, and will need to be reserved again. Reverts if enabling or disabling nodes too close before next epoch start, as set by EarthfastRegistry gracePeriod.
   */
  setNodeDisabled(
    operatorId: PromiseOrValue<BytesLike>,
    nodeIds: PromiseOrValue<BytesLike>[],
    disabled: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Does not check host or region for validity or uniqueness
   * Changes content node or topology node hosts and regions. Reverts if nodes are reserved (unless admin).
   */
  setNodeHosts(
    operatorId: PromiseOrValue<BytesLike>,
    nodeIds: PromiseOrValue<BytesLike>[],
    hosts: PromiseOrValue<string>[],
    regions: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNodePriceImpl(
    nodeId: PromiseOrValue<BytesLike>,
    epochSlot: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNodePrices(
    operatorId: PromiseOrValue<BytesLike>,
    nodeIds: PromiseOrValue<BytesLike>[],
    prices: PromiseOrValue<BigNumberish>[],
    slot: EarthfastSlotStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNodeProjectImpl(
    nodeId: PromiseOrValue<BytesLike>,
    epochSlot: PromiseOrValue<BigNumberish>,
    projectId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC165-supportsInterface}.
   */
  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  unpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unsafeImportData(
    nodes: EarthfastNodeStruct[],
    topologyCreators: PromiseOrValue<string>[],
    revokeImporterRole: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Adjusts multiple content nodes prices relative to their current values.CAUTION: This can break data consistency. Used for proxy-less upgrades.
   */
  unsafeSetPrices(
    skip: PromiseOrValue<BigNumberish>,
    size: PromiseOrValue<BigNumberish>,
    mul: PromiseOrValue<BigNumberish>,
    div: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * CAUTION: This can break data consistency. Used for proxy-less upgrades.
   */
  unsafeSetRegistry(
    registry: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
   */
  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
   */
  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    IMPORTER_ROLE(overrides?: CallOverrides): Promise<string>;

    TOPOLOGY_CREATOR_ROLE(overrides?: CallOverrides): Promise<string>;

    advanceNodeEpochImpl(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    createNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodes: EarthfastCreateNodeDataStruct[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Unregisters nodes from the network and unlocks operator stake. Reverts if nodes are reserved.
     */
    deleteNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodeIds: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reverts if the id is unknown
     */
    getNode(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<EarthfastNodeStructOutput>;

    getNodeCount(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Truncates the results if skip or size are out of bounds
     */
    getNodes(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<EarthfastNodeStructOutput[]>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.
     */
    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Called once to set up the contract. Not called during proxy upgrades.
     * @param grantImporterRole allows the contract deployer to import initial data into the contract using unsafeImport* functions, which is used for proxy-less upgrades. CAUTION: Once import is finished, the importer role should be explicitly revoked.
     */
    initialize(
      admins: PromiseOrValue<string>[],
      registry: PromiseOrValue<string>,
      grantImporterRole: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    pause(overrides?: CallOverrides): Promise<void>;

    /**
     * Returns true if the contract is paused, and false otherwise.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.
     */
    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.
     */
    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Disabled nodes won't take new reservations and won't renew when epoch ends. Disabled nodes will still keep their current reservations until the end of the current epoch. Reenabled nodes will not retain their old reservations, and will need to be reserved again. Reverts if enabling or disabling nodes too close before next epoch start, as set by EarthfastRegistry gracePeriod.
     */
    setNodeDisabled(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      disabled: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Does not check host or region for validity or uniqueness
     * Changes content node or topology node hosts and regions. Reverts if nodes are reserved (unless admin).
     */
    setNodeHosts(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      hosts: PromiseOrValue<string>[],
      regions: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setNodePriceImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNodePrices(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      prices: PromiseOrValue<BigNumberish>[],
      slot: EarthfastSlotStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setNodeProjectImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unpause(overrides?: CallOverrides): Promise<void>;

    unsafeImportData(
      nodes: EarthfastNodeStruct[],
      topologyCreators: PromiseOrValue<string>[],
      revokeImporterRole: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Adjusts multiple content nodes prices relative to their current values.CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetPrices(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      mul: PromiseOrValue<BigNumberish>,
      div: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetRegistry(
      registry: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "NodeCreated(bytes32,bytes32,string,string,bool,bool,uint256)"(
      nodeId?: PromiseOrValue<BytesLike> | null,
      operatorId?: PromiseOrValue<BytesLike> | null,
      host?: null,
      region?: null,
      topology?: null,
      disabled?: null,
      price?: null
    ): NodeCreatedEventFilter;
    NodeCreated(
      nodeId?: PromiseOrValue<BytesLike> | null,
      operatorId?: PromiseOrValue<BytesLike> | null,
      host?: null,
      region?: null,
      topology?: null,
      disabled?: null,
      price?: null
    ): NodeCreatedEventFilter;

    "NodeDeleted(bytes32,bytes32,string,string,bool,bool,uint256)"(
      nodeId?: PromiseOrValue<BytesLike> | null,
      operatorId?: PromiseOrValue<BytesLike> | null,
      host?: null,
      region?: null,
      topology?: null,
      disabled?: null,
      price?: null
    ): NodeDeletedEventFilter;
    NodeDeleted(
      nodeId?: PromiseOrValue<BytesLike> | null,
      operatorId?: PromiseOrValue<BytesLike> | null,
      host?: null,
      region?: null,
      topology?: null,
      disabled?: null,
      price?: null
    ): NodeDeletedEventFilter;

    "NodeDisabledChanged(bytes32,bool,bool)"(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldDisabled?: null,
      newDisabled?: null
    ): NodeDisabledChangedEventFilter;
    NodeDisabledChanged(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldDisabled?: null,
      newDisabled?: null
    ): NodeDisabledChangedEventFilter;

    "NodeHostChanged(bytes32,string,string,string,string)"(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldHost?: null,
      oldRegion?: null,
      newHost?: null,
      newRegion?: null
    ): NodeHostChangedEventFilter;
    NodeHostChanged(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldHost?: null,
      oldRegion?: null,
      newHost?: null,
      newRegion?: null
    ): NodeHostChangedEventFilter;

    "NodePriceChanged(bytes32,uint256,uint256,uint256,tuple)"(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldLastPrice?: null,
      oldNextPrice?: null,
      newPrice?: null,
      slot?: null
    ): NodePriceChangedEventFilter;
    NodePriceChanged(
      nodeId?: PromiseOrValue<BytesLike> | null,
      oldLastPrice?: null,
      oldNextPrice?: null,
      newPrice?: null,
      slot?: null
    ): NodePriceChangedEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "RoleAdminChanged(bytes32,bytes32,bytes32)"(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;

    "RoleGranted(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;

    "RoleRevoked(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    IMPORTER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    TOPOLOGY_CREATOR_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    advanceNodeEpochImpl(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodes: EarthfastCreateNodeDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Unregisters nodes from the network and unlocks operator stake. Reverts if nodes are reserved.
     */
    deleteNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodeIds: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Reverts if the id is unknown
     */
    getNode(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNodeCount(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Truncates the results if skip or size are out of bounds
     */
    getNodes(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.
     */
    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called once to set up the contract. Not called during proxy upgrades.
     * @param grantImporterRole allows the contract deployer to import initial data into the contract using unsafeImport* functions, which is used for proxy-less upgrades. CAUTION: Once import is finished, the importer role should be explicitly revoked.
     */
    initialize(
      admins: PromiseOrValue<string>[],
      registry: PromiseOrValue<string>,
      grantImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns true if the contract is paused, and false otherwise.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.
     */
    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.
     */
    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Disabled nodes won't take new reservations and won't renew when epoch ends. Disabled nodes will still keep their current reservations until the end of the current epoch. Reenabled nodes will not retain their old reservations, and will need to be reserved again. Reverts if enabling or disabling nodes too close before next epoch start, as set by EarthfastRegistry gracePeriod.
     */
    setNodeDisabled(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      disabled: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Does not check host or region for validity or uniqueness
     * Changes content node or topology node hosts and regions. Reverts if nodes are reserved (unless admin).
     */
    setNodeHosts(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      hosts: PromiseOrValue<string>[],
      regions: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNodePriceImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNodePrices(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      prices: PromiseOrValue<BigNumberish>[],
      slot: EarthfastSlotStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNodeProjectImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unsafeImportData(
      nodes: EarthfastNodeStruct[],
      topologyCreators: PromiseOrValue<string>[],
      revokeImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Adjusts multiple content nodes prices relative to their current values.CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetPrices(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      mul: PromiseOrValue<BigNumberish>,
      div: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    IMPORTER_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TOPOLOGY_CREATOR_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    advanceNodeEpochImpl(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodes: EarthfastCreateNodeDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Unregisters nodes from the network and unlocks operator stake. Reverts if nodes are reserved.
     */
    deleteNodes(
      operatorId: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      nodeIds: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Reverts if the id is unknown
     */
    getNode(
      nodeId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNodeCount(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Truncates the results if skip or size are out of bounds
     */
    getNodes(
      operatorIdOrZero: PromiseOrValue<BytesLike>,
      topology: PromiseOrValue<boolean>,
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.
     */
    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called once to set up the contract. Not called during proxy upgrades.
     * @param grantImporterRole allows the contract deployer to import initial data into the contract using unsafeImport* functions, which is used for proxy-less upgrades. CAUTION: Once import is finished, the importer role should be explicitly revoked.
     */
    initialize(
      admins: PromiseOrValue<string>[],
      registry: PromiseOrValue<string>,
      grantImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the contract is paused, and false otherwise.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.
     */
    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.
     */
    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Disabled nodes won't take new reservations and won't renew when epoch ends. Disabled nodes will still keep their current reservations until the end of the current epoch. Reenabled nodes will not retain their old reservations, and will need to be reserved again. Reverts if enabling or disabling nodes too close before next epoch start, as set by EarthfastRegistry gracePeriod.
     */
    setNodeDisabled(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      disabled: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Does not check host or region for validity or uniqueness
     * Changes content node or topology node hosts and regions. Reverts if nodes are reserved (unless admin).
     */
    setNodeHosts(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      hosts: PromiseOrValue<string>[],
      regions: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNodePriceImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNodePrices(
      operatorId: PromiseOrValue<BytesLike>,
      nodeIds: PromiseOrValue<BytesLike>[],
      prices: PromiseOrValue<BigNumberish>[],
      slot: EarthfastSlotStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNodeProjectImpl(
      nodeId: PromiseOrValue<BytesLike>,
      epochSlot: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unsafeImportData(
      nodes: EarthfastNodeStruct[],
      topologyCreators: PromiseOrValue<string>[],
      revokeImporterRole: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Adjusts multiple content nodes prices relative to their current values.CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetPrices(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      mul: PromiseOrValue<BigNumberish>,
      div: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * CAUTION: This can break data consistency. Used for proxy-less upgrades.
     */
    unsafeSetRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
